(load "models/arrow-object.l")
(load "package://hrpsys_ros_bridge_tutorials/euslisp/hironxjsk-interface.l")
(load "package://wrapping_melodic/euslisp/detect.l")
(ros::load-ros-package "jsk_recognition_msgs")

(hironxjsk-init)
(setq *right-coords-arrow* (arrow))
(setq *left-coords-arrow* (arrow))
(send *right-coords-arrow* :newcoords (send *hironxjsk* :rarm :end-coords :copy-worldcoords))
(send *left-coords-arrow* :newcoords (send *hironxjsk* :larm :end-coords :copy-worldcoords))
(send (send *hironxjsk* :larm :end-coords) :assoc *left-coords-arrow*)
(send (send *hironxjsk* :rarm :end-coords) :assoc *right-coords-arrow*)

;; target-coords and arrows
(setq *target-coords-right* (send (make-cascoords) :move-to (send *hironxjsk* :rarm :end-coords :copy-worldcoords) :world))
(setq *target-coords-right-arrow* (arrow))
(send *target-coords-right-arrow* :newcoords (send *target-coords-right* :copy-worldcoords))
(send *target-coords-right* :assoc *target-coords-right-arrow*)
(setq *target-coords-left* (send (make-cascoords) :move-to (send *hironxjsk* :larm :end-coords :copy-worldcoords) :world))
(setq *target-coords-left-arrow* (arrow))
(send *target-coords-left-arrow* :newcoords (send *target-coords-left* :copy-worldcoords))
(send *target-coords-left* :assoc *target-coords-left-arrow*)
(setq object-list (list *hironxjsk* *right-coords-arrow* *left-coords-arrow* *target-coords-right-arrow* *target-coords-left-arrow*))
(objects object-list)


(defun ir2ri (&optional (time 3000))
  (send *ri* :angle-vector (send *hironxjsk* :angle-vector) time)
  (send *ri* :hand-angle-vector :rhand (send *hironxjsk* :hand-angle-vector :rhand))
  (send *ri* :hand-angle-vector :lhand (send *hironxjsk* :hand-angle-vector :lhand))
  (send *ri* :wait-interpolation))
(defun ir2ri-hand ()
    (send *ri* :hand-angle-vector :rhand (send *hironxjsk* :hand-angle-vector :rhand))
    (send *ri* :hand-angle-vector :lhand (send *hironxjsk* :hand-angle-vector :lhand))
    (send *ri* :wait-interpolation))

(defun open-rhand()
  (let ((hand-angle-vector (send *hironxjsk* :hand-angle-vector :rhand)))
    (setf (aref hand-angle-vector 0) 90)
    (setf (aref hand-angle-vector 1) 0)
    (setf (aref hand-angle-vector 2) -90)
    (setf (aref hand-angle-vector 3) 0)
    (send *hironxjsk* :hand-angle-vector :rhand hand-angle-vector)
    (ir2ri-hand)))
(defun open-lhand()
  (let ((hand-angle-vector (send *hironxjsk* :hand-angle-vector :lhand)))
    (setf (aref hand-angle-vector 0) 90)
    (setf (aref hand-angle-vector 1) 0)
    (setf (aref hand-angle-vector 2) -90)
    (setf (aref hand-angle-vector 3) 0)
    (send *hironxjsk* :hand-angle-vector :lhand hand-angle-vector)
    (ir2ri-hand)))

(defun reset-pose ()
  (send *hironxjsk* :reset-manip-pose)
  (send *hironxjsk* :larm :move-end-pos #f(0 0 200) :world)
  (send *hironxjsk* :rarm :move-end-pos #f(0 0 200) :world)
  (send *hironxjsk* :stop-grasp)
  (send *hironxjsk* :head :look-at
        (send (send (send *hironxjsk* :torso :end-coords :copy-worldcoords)
                    :translate #f(500 0 0)) :worldpos))
  (send *irtviewer* :draw-objects)
  (send *ri* :angle-vector (send *hironxjsk* :angle-vector) 5000)
  (send *ri* :wait-interpolation)
  (send *ri* :stop-grasp)
  (send *ri* :wait-interpolation)
  (setq left-initial-coords (send *hironxjsk* :larm :end-coords :copy-worldcoords))
  (setq right-initial-coords (send *hironxjsk* :rarm :end-coords :copy-worldcoords))
  (setq initial-coords (send *hironxjsk* :angle-vector))
  (send *target-coords-right* :move-to (send *hironxjsk* :rarm :end-coords :copy-worldcoords) :world)
  (send *target-coords-left* :move-to (send *hironxjsk* :larm :end-coords :copy-worldcoords) :world))

(defun ri2ir ()
  (send *hironxjsk* :angle-vector (send *ri* :state :potentio-vector)))

(defun solve-ik-larm (target-coords)
  (send *hironxjsk* :larm :inverse-kinematics (send target-coords :copy-worldcoords) :rotation-axis t))
(defun solve-ik-rarm (target-coords)
  (send *hironxjsk* :rarm :inverse-kinematics (send target-coords :copy-worldcoords) :rotation-axis t))

(defun solve-ik-face (num)
  (setq *target-coords* (send (send (elt surface-location num) :copy-worldcoords) :translate (list2f (scale-vector (f2list (elt surface-normal-vector num)) 200)) :world))
  (if (or (eq num 2) (eq num 3))
      (send *target-coords* :rotate pi/2 :z))
  (send *target-coords* :rotate pi :y)
  (send (send *target-coords* :translate #f(0 0 100) :world) :rotate (deg2rad 30) :y)
  (send *hironxjsk* :larm :inverse-kinematics (send *target-coords* :copy-worldcoords) :rotation-axis t))
(defun solve-ik-sphere (deg)
  (setq *target-coords* (send (send (send (send (send (make-coords) :locate (send (send *target-bbox* :copy-worldcoords) :pos) :world)
                                          :translate (float-vector (* -1 (* (cos (deg2rad deg)) (+ (x-of-cube *target-bbox*) 150))) (* (sin (deg2rad deg)) (+ (x-of-cube *target-bbox*) 150)) 0) :world) :rotate (* -1 (deg2rad deg)) :z)
                                    :translate #f(0 0 80) :world) :rotate (deg2rad 30) :y))
  (solve-ik-larm *target-coords*)
  )

(defun write-txt-deg (deg file-path)
  (with-open-file (file file-path :direction :output :if-exists :append :if-does-not-exist :create)
                  (format file "~A~%" deg)))
(defun write-txt-pos (pos file-path)
  (with-open-file (file file-path :direction :output :if-exists :append :if-does-not-exist :create)
                  (format file "~A ~A ~A ~%" (elt pos 0) (elt pos 1) (elt pos 2))))
(defun write-txt-rot (rot file-path)
  (with-open-file (file file-path :direction :output :if-exists :append :if-does-not-exist :create)
                  (format file "~A ~A ~A ~A ~A ~A ~A ~A ~A~%" (aref rot 0 0) (aref rot 0 1) (aref rot 0 2) (aref rot 1 0) (aref rot 1 1) (aref rot 1 2) (aref rot 2 0) (aref rot 2 1) (aref rot 2 2))))

(defun write-txt-and-solve-ik-sphere (deg file-path)
  (solve-ik-sphere deg)
  (write-txt-deg deg file-path)
  (write-txt-pos (send (send *hironxjsk* :larm :end-coords :copy-worldcoords) :pos) file-path)
  (write-txt-rot (send (send *hironxjsk* :larm :end-coords :copy-worldcoords) :rot) file-path))

(defun detect-pose ()
  (send *target-coords-right* :translate #f(0 -300 0))
  (solve-ik-rarm *target-coords-right*)
  (send *target-coords-left* :translate #f(0 300 0))
  (solve-ik-larm *target-coords-left*))
