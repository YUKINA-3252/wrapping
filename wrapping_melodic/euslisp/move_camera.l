(load "models/arrow-object.l")
(load "package://hrpsys_ros_bridge_tutorials/euslisp/hironxjsk-interface.l")
(load "package://wrapping_melodic/euslisp/detect.l")
(ros::load-ros-package "jsk_recognition_msgs")

(hironxjsk-init)
(setq *right-coords-arrow* (arrow))
(setq *left-coords-arrow* (arrow))
(send *right-coords-arrow* :newcoords (send *hironxjsk* :rarm :end-coords :copy-worldcoords))
(send *left-coords-arrow* :newcoords (send *hironxjsk* :larm :end-coords :copy-worldcoords))
(send (send *hironxjsk* :larm :end-coords) :assoc *left-coords-arrow*)
(send (send *hironxjsk* :rarm :end-coords) :assoc *right-coords-arrow*)
(setq object-list (list *hironxjsk* *right-coords-arrow* *left-coords-arrow*))
(objects object-list)


(defun ir2ri (&optional (time 3000))
  (send *ri* :angle-vector (send *hironxjsk* :angle-vector) time)
  (send *ri* :hand-angle-vector :rhand (send *hironxjsk* :hand-angle-vector :rhand))
  (send *ri* :hand-angle-vector :lhand (send *hironxjsk* :hand-angle-vector :lhand))
  (send *ri* :wait-interpolation))
(defun ir2ri-hand ()
    (send *ri* :hand-angle-vector :rhand (send *hironxjsk* :hand-angle-vector :rhand))
    (send *ri* :hand-angle-vector :lhand (send *hironxjsk* :hand-angle-vector :lhand))
    (send *ri* :wait-interpolation))

(defun open-rhand()
  (let ((hand-angle-vector (send *hironxjsk* :hand-angle-vector :rhand)))
    (setf (aref hand-angle-vector 0) 90)
    (setf (aref hand-angle-vector 1) 0)
    (setf (aref hand-angle-vector 2) -90)
    (setf (aref hand-angle-vector 3) 0)
    (send *hironxjsk* :hand-angle-vector :rhand hand-angle-vector)
    (ir2ri-hand)))
(defun open-lhand()
  (let ((hand-angle-vector (send *hironxjsk* :hand-angle-vector :lhand)))
    (setf (aref hand-angle-vector 0) 90)
    (setf (aref hand-angle-vector 1) 0)
    (setf (aref hand-angle-vector 2) -90)
    (setf (aref hand-angle-vector 3) 0)
    (send *hironxjsk* :hand-angle-vector :lhand hand-angle-vector)
    (ir2ri-hand)))

(defun reset-pose ()
  (send *hironxjsk* :reset-manip-pose)
  (send *hironxjsk* :larm :move-end-pos #f(0 0 200) :world)
  (send *hironxjsk* :rarm :move-end-pos #f(0 0 200) :world)
  (send *hironxjsk* :stop-grasp)
  (send *hironxjsk* :head :look-at
        (send (send (send *hironxjsk* :torso :end-coords :copy-worldcoords)
                    :translate #f(800 0 0)) :worldpos))
  (send *irtviewer* :draw-objects)
  (send *ri* :angle-vector (send *hironxjsk* :angle-vector) 5000)
  (send *ri* :wait-interpolation)
  (send *ri* :stop-grasp)
  (send *ri* :wait-interpolation)
  (setq left-initial-coords (send *hironxjsk* :larm :end-coords :copy-worldcoords))
  (setq right-initial-coords (send *hironxjsk* :rarm :end-coords :copy-worldcoords))
  (setq initial-coords (send *hironxjsk* :angle-vector)))

(defun ri2ir ()
  (send *hironxjsk* :angle-vector (send *ri* :state :potentio-vector)))

(defun solve-ik-face (num)
  (setq *target-coords* (send (send (elt surface-location num) :copy-worldcoords) :translate (list2f (scale-vector (f2list (elt surface-normal-vector num)) 200)) :world))
  (if (or (eq num 2) (eq num 3))
      (send *target-coords* :rotate pi/2 :z))
  (send *target-coords* :rotate pi :y)
  (send (send *target-coords* :translate #f(0 0 100) :world) :rotate (deg2rad 30) :y)
  (send *hironxjsk* :larm :inverse-kinematics (send *target-coords* :copy-worldcoords) :rotation-axis t))

(reset-pose)
(open-lhand)
(detect)
(solve-ik-face 1)
(ir2ri)
(solve-ik-face 3)
